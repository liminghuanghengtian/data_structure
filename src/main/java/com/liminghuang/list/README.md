# 1. ArrayList
采用**可变大小的数组**实现List接口，默认增长为1.5倍。ArrayList会随着元素的增加其容积自动扩大，非同步。除此之外，几乎与Vectorc操作是同等的。

## 1.1 特性

1. 主要底层实现是<font color="red">**对象数组**</font>；
2. 和LinkedList相比，它的**查找和访问**元素的速度较快，但**新增，删除**的速度较慢（非绝对）。所以主要使用场景是查询，扬长避短；
3. 可在**构造时初始化底层数组大小**，或者通过无参构造初始化成**默认空数组**，添加数据时才分配默认长度为10的初始容量；为什么是10？10是基于调研的一个常用且最有效的；
4. 可通过**数组扩容**的方式去避免数组有限长度的问题，达到无限制长度的效果；
5. ArrayList(int initialCapacity)会初始化数组大小，但是<font color="red">**List大小是返回size的，所以构造时List大小是无变化的**</font>，add操作之后才会增加List的大小；所以不能在构造ArrayList之后直接进行set操作，因为set内部下标是和size比较的；
6. 线程不安全，线程安全可使用**Vector(同步在方法上)**，或者**用Collections.synchronizedList包装**一个线程安全版本的数组容器使用（方法内同步语句块）；
7. **不适合做队列**。队列特性先进先出，能通过尾部新增，头部移除实现，但是涉及到数据移动，速度慢；
8. 数组适合做队列。前提是<font color="red">**定长数组**，通过两个偏移量来标记读和写的位置来满足，如果超过长度就折回到数组开头；例如：*数组阻塞队列ArrayBlockingQueue*</font>
9. **遍历性能优于LinkedList**。因为底层数组实现，分配的内存连续。CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。

## 1.2 扩容操作

1. 何时需要扩容？数组空间已填满，无法插入元素
2. 扩容算法？N+N/2 = 1.5N（N为当前数组长度，所以未指定数组长度的情况，正常的扩容长度依次会是10，15，22，33...）
3. 如何扩容？把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数组的地址换到新数组

## 1.3 增删操作

### 1.3.1 新增操作

新增操作分两类：指定`index`新增和尾部新增

#### 第一种：尾部新增

1. 确认数组长度（是否扩容，是则完成扩容）
2. 加入尾部

#### 第二种：指定index新增

1. 确认插入index合法
2. 确认数组长度（是否扩容，是则完成扩容）
3. 指定index开始的数据后移（通过native实现的数组拷贝来完成。并没有真正的拷贝方法，实则通过将index及之后元素一个个后移，清理出index位置的空间）
4. 在index处插入数据

综合上面两种新增方式，不难发现新增速度慢的特性描述并非绝对，是在一定的场景下得出。显然在指定index新增比较符合特性描述，因为即便拷贝操作是在native完成，但是数据量大了之后，根据上述介绍拷贝的原理，这并非是一个高性能的操作。而且扩容操作也涉及到拷贝的过程。

### 1.3.2 删除操作

#### 介绍一种：指定`index`移除

1. 确认删除index合法
2. 指定index之后的数据前移(还是同上通过数组拷贝完成)，实则覆盖非删除

同新增方式大同小异，数组容量大，效率堪忧。

## 1.4 总结

依其名ArrayList，一个动态数组。

# 2. LinkedList
LinkedList类采用Deque规范（双端队列）的链表结构实现List接口，所以LinkedList在**插入**和**删除**操作效率会比较高。而且还提供了在List的开头和结尾进行`get`，`remove`，`insert`等操作。

- poll（）：将队首的元素删除，并返回该元素。
- peek（）：返回队首的元素，但不进行删除操作。
- offer（）：将元素添加到队尾，如果成功，则返回true。

# 3. CopyOnWriteArrayList
基于COW(Copy-On-Write)思想，具体是指在对数组做涉及`set`，`add`，`remove`等写操作时，先copy数组的一个备份数组，然后对备份数组执行相应操作后，最后再将原来的数组引用指向到新数组。当然为了防止多个线程同时写入导致数据错乱，需要增加同步控制。

一个线程安全的 {@link java.util.ArrayList}变种。其中所有的可变操作({@code add}， {@code set}，等等)都是通过创建底层数组的新副本来实现的。

## 3.1 特性
1. 线程安全，依据COW写时拷贝思想，写入操作会加锁，防止多线程并发进行写入修改，导致最终数据不一致
2. 非实时读（写需要时间，写是在一个新的数组内存空间，读操作可能还是读到旧的数据内容），只能保证最终一致性
3. 内部存储大容量的数组对象的话，copy时容易导致内存抖动，频繁的创建数组消耗内存
4. 默认无参构造是一个空对象数组`public CopyOnWriteArrayList() { setArray(new Object[0]); }`
5. 迭代器是基于当前`object[]`对象数组的一个快照，**不能在迭代时修改，否则抛出异常**`public void remove() { throw new UnsupportedOperationException(); }`
6. 允许`null`值
## 3.2 [相关的young gc和full gc](https://www.jianshu.com/p/76959115d486)
